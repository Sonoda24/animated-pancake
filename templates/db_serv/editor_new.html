{% include 'db_serv/editor_header.html' %}
    <nav class="navbar navbar-expand-sm navbar-dark navbar-default mt-3 mb-3 navbar-fixed-bottom">
      <ul id="menu01">
	<!--form name="selbox" -->
	<select name="edit" onchange="edit_mode()" style="width:60px; height:25px;" ></p>
	<option value="">Display</option>
	<option value="">Edit</option>
	</select>
	<select name="fgedit" onchange="chng_mode()" style="width:60px; height:25px;" ></p>
	<option value="">Visual</option>
	<option value="">Html</option>
	<option value="">Svg</option>
	<option value="">Mod Svg</option>
	</select>
	<!-- /form -->
        <button id="clear">clear</button>
        <select name="control" id="control" style="width:60px; height:25px;" ></p>
    		<option value="line">serial line</option>
    		<option value="close_line">closed line</option>
		<option value="cubic_bezier">smooth</option>
		<option value="cubic_bezier">closed smooth</option>
		<option value="quad_bezier">quad bezier</option>
		<option value="cubic_bezier">cubic bezier</option>
    		<option value="free_line">free line</option>
  	</select>
	<!-- span class="icon-link" style="width:25px; height:25px;"></span>
	<span class="icon-database" style="width:25px; height:25px;"></span -->
	<!--button id="link" class="icon-link" style="width:25px; height:25px;"></button>
	<button id="doc_save" class="icon-database" style="width:25px; height:25px;"></button -->
	<span class="icon-link" onclick="link()" style="width:25px; height:25px;"></span>
	<span class="icon-database" onclick="doc_save()" style="width:25px; height:25px;"></span>
	<button id="bold">bold</button>
        <button id="createWindow">popup</button>
	<button id="h3">h3</button>
	<button id="select">Msvg</button>
	<!--button id="doc_save">保存</button -->
	<button id="chara">文字変更</button>
        <button id="trig1">選択1</button>
	<button id="trig2">選択2</button>
        <span id="cp01" onclick="cmanCP_JS_open(this)" cmanCPat="def_color:val=sample1,def_alpha:0,rc_text:sample1,rc_form:#16,rc_bg:cp01"></span>
        <input type='text' value="#0000ff" id="sample1" style="width:60px; height:25px;" onchange="check_color()" style="display: inline-block; _display: inline;">
	<input type="file" id="selfile" style="display: inline-block; _display: inline;">
        <span class="clear"></span> <!-- クリアー用の空divだよ -->
     </ul>
  <!-- ul id="canvasmenu">
    <li class="menuicon" id="size14px">14</div>
    <li class="menuicon" id="size7px">7</div>
    <li class="menuicon" id="size5px">5</div>
    <li class="menuicon" id="size3px">3</div>
    <li class="menuicon" id="size2px">2</div>
    <li class="menuicon" id="size1px">1</div>
    <li class="menuicon" id="colore91e63" style="background-color:#e91e63">○</div>
    <li class="menuicon" id="colorffeb3b" style="background-color:#ffeb3b">○</div>
    <li class="menuicon" id="colorff4801" style="background-color:#ff4801">○</div>
    <li class="menuicon" id="color536dfe" style="background-color:#536dfe">○</div>
    <li class="menuicon" id="color009688" style="background-color:#009688">○</div>
    <li class="menuicon" id="color00e676" style="background-color:#00e676">○</div>
    <li class="menuicon" id="color555555" style="background-color:#555555">○</div>
    <li class="menuicon" id="alpha10" style="background-color:rgba(255,72,1, 1.0)">10</div>
    <li class="menuicon" id="alpha6" style="background-color:rgba(255,72,1, 0.6)">6</div>
    <li class="menuicon" id="alpha3" style="background-color:rgba(255,72,1, 0.3)">3</div>
    <li class="menuicon" id="alpha1" style="background-color:rgba(255,72,1, 0.1)">1</div>
  </ul -->
  </nav>

<div class="container-fluid">
<div class="container">
  <div class="row">
    <div class="col-md-3 sidenav hidden-xs"><br><br>

	<!-- サブメニュー（左カラム） -->
	<form name="selbox">
	<p><label>課題名</label><br>
	<select id="comboboxA" onchange="changeCombA()" style="height:25px; width:180px;"></select>
	<p><label>大分類</label><br>
	<select id="comboboxB"  onchange="changeCombB()" style="height:25px; width:180px;"></select>
	<p><label>中分類</label><br>
	<select id="comboboxC"  onchange="changeCombC()" style="height:25px; width:180px;"></select>
	<p><label>小分類</label><br>
	<select id="comboboxD"  onchange="changeCombD()" style="height:25px; width:180px;"></select>
	</form>
    </div><!-- End col-sm-3 -->
    <br>
    <div class="col-sm-9">
	<!-- メインメニュー -->
    <div class="tab-pane" id="tab1"><!-- Start tab1 -->
	<!--canvas id="myCanvas" class="canv" ></canvas -->
        <svg id="myCanvas" class="canv" width="1000" height="1000" viewBox="10 50 1000 1000" xmlns="http://www.w3.org/2000/svg">
	</svg>
	<div class="Tvis" id="texx" contenteditable="flase"></div>
    </div><!-- End tab1 -->
    <div class="tab-pane active" id="tab2"><!-- Start tab2 -->
       <textarea class="Thtm" id="texh" contenteditable="false"></textarea>
    </div><!-- End tab2 -->
    </div><!-- End col-sm-9 -->
    <div class="clearfix visible-lg"></div>
  </div><!-- End row -->
</div>

</div>
<script>
    var clickCount = 0 ;
    var Up_count=0;
    var Move_mode=0;
    var mouse_Error=false;

    var container = document.getElementById('myCanvas');
    var clear = document.getElementById('clear');
    var mv_flag=10;

    clear.onclick = function() {
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }
    }

    bold.onclick = function() {
    const selectedText = window.getSelection().toString();
console.log(selectedText);

    var sel = window.getSelection();
    if(!sel.rangeCount) return; //範囲選択されている箇所がない場合は何もせず終了

    var range = sel.getRangeAt(0);　　　　　　　　　　　//　OK!!
    var newNode = document.createElement('b');
    newNode.innerHTML =  sel.toString();   //選択文字列をnewNodeとして設定
    range.deleteContents();    // 範囲選択箇所を一旦削除
    range.insertNode(newNode); // 前後に<b>と</b>を入れる。
    }

  select.onclick = function() {
    //htmlのSVG
　　const svgtag = document.querySelector('#myCanvas');
	var level=0;
	svg_list(svgtag,level);	
    }
  function svg_list(svgtag,level){
    level=level+1;
    var leng=svgtag.children.length;
console.log('svg_list level= ',level,'child leng= ',svgtag.children.length,svgtag);
    for (var i=0 ;i<leng ;i++){
	tagn=svgtag.children[i];
console.log('**nodename= ',tagn.nodeName);
	if(tagn.children.length) {
		svg_list(tagn,level);
		}
	else {
console.log('Svg text=',tagn.outerHTML);
//		const domParser = new DOMParser();
//    　　	const parsedSVGDoc = domParser.parseFromString(tagn.outerHTML, 'image/svg+xml');
//console.log(parsedSVGDoc);

//		var oDOM = domParser.parseFromString(tagn.outerHTML, "application/xml");
// print the name of the root element or error message
//console.log(oDOM.documentElement.nodeName == "parsererror" ? "error while parsing" : oDOM.documentElement.nodeName);
//console.log(oDOM);
//var oSerializer = new XMLSerializer();
//var sXML = oSerializer.serializeToString(tagn);
//console.log(sXML)
//JavaScript 属性値を取得/設定/削除する(getAttribute)
		attr_char=tagn.getAttribute("d"); 
console.log('**attr= ',attr_char);
		if(attr_char){
			replaced = attr_char.replace(/-/g, ',-');
console.log(replaced);
			var result = replaced.split(/,|M|T|Q|q|S|s|C|c|L|l|Z/);     // '-'を分割文字にするとマイナス符号と見做さないのでまずい
console.log('leng=',result.length,result);
//(x,y)のペアを作りさらに形式を変えて（作図用）保存
			r_val=[];
			for ( var i = 0 ; i < result.length ; i++ ){
				if (result[i]!="") {
					val=Number(result[i]);
					r_val.push(val);
					}
				}
console.log('r_val=',r_val);
			path_p=[];
			result=splitArray(r_val,2);
console.log('Result=',result,'r_val=',r_val);
			for(var k=0; k<result.length;k++){
				path_p.push({x: result[k][0],y: result[k][1]});
				}
console.log('path_p= ',path_p);
//円を描いてみる
			for(var k=0; k<path_p.length;k++){
console.log(path_p[k]);
				first_point=createFirstPoint([path_p[k]]);
	        		Object.assign(first_point.style, defaultPointStyle);
        			container.appendChild(first_point);
				}
			}
		}
	}
    }

  function link() {
//console.log(selectedText);
    var sel = window.getSelection();
    if(!sel.rangeCount) return; //範囲選択されている箇所がない場合は何もせず終了

    var range = sel.getRangeAt(0);　　　　　　　　　　　//　OK!!
    var newNode =document.createElement('a');
    var user = window.prompt("link先を入力してください", "");
//console.log(user);
    newNode.href = user;
    newNode.innerHTML = sel.toString();   //tag部分に<>を含むと変更出来ない。
    range.deleteContents();    // 範囲選択箇所を一旦削除
    range.insertNode(newNode); 
    }

  h3.onclick = function() {
    const selectedText = window.getSelection().toString();
console.log(selectedText);

    var sel = window.getSelection();
    if(!sel.rangeCount) return; //範囲選択されている箇所がない場合は何もせず終了

    var range = sel.getRangeAt(0);　　　　　　　　　　　//　OK!!
    var newNode = document.createElement('h3');
//  newNode.setAttribute('style', 'background-color: blue;'); //範囲選択箇所の背景を青にする
    newNode.innerHTML = sel.toString();   //tag部分に<>を含むと変更出来ない。
    range.deleteContents();    // 範囲選択箇所を一旦削除
    range.insertNode(newNode); // 範囲選択箇所の先頭から、修飾したspanを挿入
    }

    var prev=0;
    var check_count;

  $("#trig1").bind("click", (function () {
    var subWinObj1='cmanCP_POP';
//    alert("Trigger is clicked!");
    $("#cp01").trigger("click");
    prev=10;
    document.getElementById("cmanCP_POP" ).style.zIndex ='100';
    check_count=0;
    setTimeout("check_color()",200);
    }));

  $("#trig2").bind("click", (function () {
    var subWinObj1='cmanCP_POP';
//    alert("Trigger is clicked!");
    $("#cp01").trigger("click");
    prev=20;
    document.getElementById("cmanCP_POP" ).style.zIndex ='100';
    check_count=0;
    setTimeout("check_color()",200);
    }));

  function check_color() {
//console.log('Enter check_color',check_count);
    //値が変更されたときの処理
    if(!document.getElementById("cmanCP_POP")) {
	if (prev==10) {
		var col_code=document.getElementById("sample1" ).value;
        	document.querySelector('#trig1').style.backgroundColor = col_code;
//console.log('color=',col_code);
 	    	}
	if (prev==20) {
		var col_code=document.getElementById("sample1" ).value;
        	document.querySelector('#trig2').style.backgroundColor = col_code;
//console.log('color=',col_code);
	    	}
	}
    else {
	check_count=check_count+1;
	if(check_count>50) {
		return;
		}
	setTimeout("check_color()",200);
	}
    }

    chara.onclick = function() {
const selectedText = window.getSelection().toString();
colval=document.querySelector('#trig1').style.backgroundColor;
console.log('Sel_text=',selectedText,'color=',colval);

var sel = window.getSelection();
  if(!sel.rangeCount) return; 

  var range = sel.getRangeAt(0);　　　　　　　　　　　//OK!!　<font>でも下記の<span>でもOK
  var font = document.createElement("font");
  font.style.color = colval;
  range.surroundContents(font);

//  var span = document.createElement("span");     //OK
//  span.style.color = colval;
//  range.surroundContents(span);

    }
/*          Ajax POST で必要となるか？？？？？？？？？？？
 function getCookie(name) {
            var cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                var cookies = document.cookie.split(';');
                for (var i = 0; i < cookies.length; i++) {
                    var cookie = jQuery.trim(cookies[i]);
                    // Does this cookie string begin with the name we want?
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

var csrftoken = getCookie('csrftoken');

function csrfSafeMethod(method) {
            // these HTTP methods do not require CSRF protection
            return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
        }

$.ajaxSetup({
            beforeSend: function (xhr, settings) {
                if (!csrfSafeMethod(settings.type) && !this.crossDomain) {
                    xhr.setRequestHeader("X-CSRFToken", csrftoken);
                }
            }
        });
*/
//function SVG_select() {
//}

function doc_save() {
//    doc_save.onclick = function() {
console.log('*** SAVE　Entered  Direct to server ***');
	var tex_to_serv=escapeHtml(escape(document.getElementById("texx").innerHTML));
	var svg_tags=document.querySelector('#myCanvas');
console.log('**Svg_tag length=',svg_tags.childElementCount);
	svg_tag='';
	for (nn = 0; nn < svg_tags.childElementCount; nn++) {
		svg_tag=svg_tag+svg_tags.children[nn].outerHTML+'|<=>|';
console.log('***list n =',nn,' length = ', svg_tag.length);
		}
	var svg_tag=escapeHtml(escape(svg_tag));
console.log('svg_tag',svg_tag);
console.log(tex_to_serv);
        $.ajax({
            url: "/db_serv/update/",
            data: {
		"description":tex_to_serv,
		"svg":svg_tag,
		},
            dataType: 'json'
        })
        .done((data) => {
            //結果が帰ってきたら、表示します。
            //$('#answer').html('<span class="flower-answer-text">' + data['result'] + '</span>');
console.log('**Ajax Returned result=',data);
        });
   }

/* SVGfileの読み込み　　　　　　　　　　　　　*/
　　var obj1 = document.getElementById("selfile");
　　//ダイアログでファイルが選択された時
　　obj1.addEventListener("change",function(evt){
  　var file = evt.target.files;
　　//FileReaderの作成
  　var reader = new FileReader();
  　//テキスト形式で読み込む
  　reader.readAsText(file[0]);
  　
  　//読込終了後の処理
  　reader.onload = function(ev){
    //テキストエリアに表示する
    //document.test.txt.value = reader.result;

　　//const svgText = SVGData;
　　//svgText=document.test.txt.value;
　　svgText = reader.result;
　　const domParser = new DOMParser();
　　const parsedSVGDoc = domParser.parseFromString(svgText, 'image/svg+xml');
　　console.log(parsedSVGDoc.childNodes[0]);
　　const parsedSVG = parsedSVGDoc.childNodes[0];
 
　　//htmlのSVG
　　const svg = document.querySelector('#myCanvas');
　　//生成したSVGをhtmlにそのまま入れる
　　svg.appendChild(parsedSVG);
  　　}
　　},false);
//
    var isDrawing = false;
    var drawingPoints=[];
    var drawingPath=null;
    var Oper=0;
    var Step=0;
    var Svg_continue=0;
    var bz_path='';
    var bz_attribute='';
    var qd_path='';
    var qd_attribute='';
    var bezier_line='';
    var bezier_line1='';
    var first_point='';

    var defaultPathStyle = {
        strokeWidth: "3px",
        stroke: "#000",
        strokelinecap:"round",
        fill: "none",
    };
    var defaultPointStyle = {
        strokeWidth: "1px",
        stroke: "red",
	strokelinecap:"round",
        fill: "none",
    };
    var tempoPathStyle = {
        strokeWidth: "1px",
        stroke: "red",
        fill: "none",
    };
    var tempoPathStyle2 = {
        strokeWidth: "1px",
        stroke: "blue",
        fill: "none",
    };

//mousedownのカウントとマウス動作判定用　dblclick,click,Move_mode(mouseupしていない）かの判定
    container.addEventListener( "mousedown", function( e ) {
	++clickCount ;
console.log('mousedown');
	if(clickCount==1){             //最初のmousedown後から350ミリ秒待つ（その間clickをカウント）
		setTimeout(mouse_handle,350,e);　//dblclick,click,Move_modeかの判定は下の mouse_handle関数で実施
	}
    });

   var mouse_handle=function(e){
			Move_mode=0;
			if(clickCount>=2){
				if(clickCount==Up_count) {
					console.log('Double clicked');
					mode='dblclick';
				}
				else {
					console.log('Pretend Double clicked');
					mode='dblclick';
					mouse_Error=true;
				}
			}
			else {
				if(clickCount==Up_count) {
					console.log('Clicked')
					mode='click';
				}
				else {
					Move_mode=1;
					console.log('Down mode')
					mode='Move_mode';
				}
			}
			console.log('down=',clickCount,'Up_count=',Up_count);
		clickCount=0;
		Up_count=0;

	if ((E_mode=='Edit')&&(Editmode=='Svg')&&(mode=='dblclick')) {
		dbl_click_func(e);
	}
	if ((E_mode=='Edit')&&(Editmode=='Svg')&&(mode=='click')){
		click_func(e);
	}
	if ((Editmode=='Tvis')&&(mode=='click')){
//		Text_edit();
	}
}

//メニューのアイコン関係
    var menuIcon = document.getElementsByClassName("menuicon");
    for (i = 0; i < menuIcon.length; i++) {
        menuIcon[i].addEventListener("click", canvasMenu, false)
    }

//　ブラウザ表示用データの準備
      var texxx=unescapeHtml(unescape("{{view_tex}}"));
      document.getElementById("texx").innerHTML=texxx;
      var svg_tex=unescapeHtml(unescape("{{svg_field}}"));
//console.log('**svg length=',svg_tex.length,' tex=',svg_tex);
      if(svg_tex!=''){
　　　　　const svg = document.querySelector('#myCanvas');
	  var n_s=0;
	  var i=0;
	  var n_last=svg_tex.length;
	  do {
             i = i + 1;
      	     n_e = svg_tex.indexOf('|<=>|',n_s );
	     if(n_e<0) {
		n_e=n_last;
		}	     
console.log('num=',i,' n_start and n_last=',n_s,n_e,n_last);
	     text_n=svg_tex.substring(n_s , n_e);
console.log('num= ',i,' tex= ',text_n)
	     n_s=n_e+5;
             const domParser = new DOMParser();
　　	     parsedSVGDoc = domParser.parseFromString(text_n, 'image/svg+xml');
   	     parsedSVG = parsedSVGDoc.childNodes[0];
　　	     svg.appendChild(parsedSVG);
	     svg.lastChild.outerHTML=text_n
	     } while (n_s < n_last);
	  }
		Editmode="Tvis";
		E_mode="Display";
		nodisp=document.getElementById('tab2');
       		nodisp.style.display='none';
       		disp=document.getElementById('tab1');
       		disp.style.display='block';
//document.getElementById("bbb").style.display="block";
document.getElementById("myCanvas").style.display="block";
//　　　　　　	document.getElementById("texh").contentEditable = false;
//　　　　　　	document.getElementById("texx").contentEditable = false;
		document.getElementById( "texx" ).style.zIndex ='40';
		document.getElementById( "texh" ).style.zIndex ='20';
//		document.getElementById( "myCancas" ).style.zIndex ='20';
		document.getElementById("texh").value=document.getElementById("texx").innerHTML;

//ダブルクリック時の処理を入れる
var dbl_click_func=function(e){
// ダブルクリックイベントの処理内容
console.log( "ダブルクリック!!" ) ;
// クリック回数をリセット
	clickCount = 0 ;
	Oper=2;
	if ((control.value== 'line')||(control.value== 'close_line')){
        	drawingPoints.push({x: e.clientX,y: e.clientY});
		var close=0;
		if(control.value== 'close_line') {
			close=1;
			drawingPoints.push(drawingPoints[0]);
			}
        	container.removeChild(drawingPath);
        	drawingPath = null;
        	var path;
//console.log(drawingPoints);
//bezier test 
console.log(drawingPoints);
//		resultPoints=catmullRom2bezier(drawingPoints);
		path_p=Cubic_interpol(drawingPoints);
console.log('Path_P=',path_p);

		for (var i=0;i<path_p.length;i++){
				first_point=createFirstPoint([path_p[i]]);
	        		Object.assign(first_point.style, defaultPointStyle);
        			container.appendChild(first_point);
			}
/*
console.log('Result Points= ',resultPoints);
		path_p=[drawingPoints[0]];
		for ( var i = 0 ; i < resultPoints.length-1 ; i++ ){
			result=splitArray(resultPoints[i],2);
//console.log('Array=',result);
			for(var k=0; k<result.length;k++){
				path_p.push({x: result[k][0],y: result[k][1]});
//				path_p.push(result[k]);
//console.log('New Points= ',path_p);
				}
			}
console.log('New Points= ',path_p);
*/
        	path = createPath(drawingPoints,close);
        	Object.assign(path.style, defaultPathStyle);
        	container.appendChild(path);

		bez_path=createCubicBezier(path_p)
		Object.assign(bez_path.style, defaultPathStyle);
        	container.appendChild(bez_path);
/*
		qd_path=createQuadBezier(path_p)
		Object.assign(qd_path.style, tempoPathStyle);
        	container.appendChild(qd_path);
*/
		Oper=0;
		Step=0;
		drawingPoints = [];
		}
	if ((control.value== 'quad_bezier')||(control.value== 'cubic_bezier')){
            	if (bezier_line){
			container.removeChild(bezier_line);
			bezier_line=null;
			}
            	if (bezier_line1){
			container.removeChild(bezier_line1);
			bezier_line1=null;
			}
		if (first_point){
			container.removeChild(first_point);
			first_point=null;
			}
		if (control.value== 'quad_bezier'){
			if (drawingPath) {
       				container.removeChild(drawingPath);
            			}
                	drawingPath = createQuadBezier(drawingPoints);
            		Object.assign(drawingPath.style, defaultPathStyle);
            		container.appendChild(drawingPath);
			}
		if (control.value== 'cubic_bezier'){
			if (drawingPath) {
       				container.removeChild(drawingPath);
            			}
                	drawingPath = createCubicBezier(drawingPoints);
            		Object.assign(drawingPath.style, defaultPathStyle);
            		container.appendChild(drawingPath);
			}
console.log("bezier final");
		Oper=0;
		Step=0;
		Svg_continue=0;
		first_point='';
		drawingPoints = [];
//console.log('bezier dummy removed');
		}
}
//Singleクリック時の処理を入れる
var click_func=function(e){
console.log('Singleクリック',control.value,'Step=',Step);
	Oper=3;
	if (Step==0) {
		//free lineなどの残骸を消して開始する
		isDrawing=0;
		if (drawingPath) {
//                	container.removeChild(drawingPath);
			drawingPath=null;
			}
        	drawingPoints = [];
console.log("****Initialized");
		}
	Step+=1;
        drawingPoints.push({x: e.clientX, y: e.clientY});
	if ((control.value== 'line')||(control.value== 'close_line')){
		line_seq(Step);
		}
	if (control.value== 'quad_bezier'){
		quad_bezier_seq(Step);
		}
	if (control.value== 'cubic_bezier'){
		cubic_bezier_seq(Step);
		}
	}

function line_seq(Step){
//console.log('switch=',sw_flag);
	if(drawingPoints.length==1){
		first_point=createFirstPoint(drawingPoints)
	        Object.assign(first_point.style, defaultPointStyle);
        	container.appendChild(first_point)
		}
	else {
		if (first_point){
			container.removeChild(first_point);
			first_point=null;
			}
		}
       if (drawingPath) {
       			container.removeChild(drawingPath);
            		}
        	drawingPath = createPath(drawingPoints,0);
        	Object.assign(drawingPath.style, defaultPathStyle);
        	container.appendChild(drawingPath);
//console.log('Path=',drawingPath);
	}

function quad_bezier_seq(Step){
console.log('Step=',Step);
	mStep=Step%3;
	if(mStep==1){	
		first_point=createFirstPoint([drawingPoints[drawingPoints.length-1]]);
	        Object.assign(first_point.style, defaultPointStyle);
        	container.appendChild(first_point)
		}
console.log('Bezier',Step,'length=',drawingPoints.length);
	if (mStep==2) {
//console.log(' last line= ',drawingPoints,[drawingPoints[drawingPoints.length-2],drawingPoints[drawingPoints.length-1]]);
		bezier_line=createPath([drawingPoints[drawingPoints.length-2],drawingPoints[drawingPoints.length-1]],0)
	        Object.assign(bezier_line.style, tempoPathStyle);
        	container.appendChild(bezier_line)

		if (first_point){
			container.removeChild(first_point);
			first_point=null;
			}
		}
	if(mStep==0) {
		if (drawingPath) {
       			container.removeChild(drawingPath);
            		}
                drawingPath = createQuadBezier(drawingPoints);
            	Object.assign(drawingPath.style, defaultPathStyle);
            	container.appendChild(drawingPath);

		if (bezier_line){
			container.removeChild(bezier_line);
			bezier_line=null;
console.log('cubic bezier dummy removed length=',drawingPoints.length);
			}
		}
console.log('append bezier');
}

function cubic_bezier_seq(Step){
console.log('Step=',Step);
	mStep=Step%4;
	if(mStep==1){	
		first_point=createFirstPoint([drawingPoints[drawingPoints.length-1]]);
	        Object.assign(first_point.style, defaultPointStyle);
        	container.appendChild(first_point)
		}
//console.log('Cubic Bezier',Step,'length=',drawingPoints.length);
	if(mStep==2){
console.log('Cubic Bezier line');
		bezier_line=createPath([drawingPoints[drawingPoints.length-2],drawingPoints[drawingPoints.length-1]],0)
	        Object.assign(bezier_line.style, tempoPathStyle);
       		container.appendChild(bezier_line)

		if (first_point){
			container.removeChild(first_point);
			first_point=null;
			}
		}
	if(mStep==3){
console.log('Cubic Bezier line');
		bezier_line1=createPath([drawingPoints[drawingPoints.length-2],drawingPoints[drawingPoints.length-1]],0)
	        Object.assign(bezier_line1.style, tempoPathStyle);
       		container.appendChild(bezier_line1)
		}
	if(mStep==0) {
		if (drawingPath) {
       			container.removeChild(drawingPath);
            		}
                drawingPath = createCubicBezier(drawingPoints);
            	Object.assign(drawingPath.style, defaultPathStyle);
            	container.appendChild(drawingPath);

		if (bezier_line){
			container.removeChild(bezier_line);
			bezier_line=null;
			}
		if (bezier_line1){
			container.removeChild(bezier_line1);
			bezier_line1=null;
			}
		}
console.log('Cubic Bezier line',drawingPoints);
}

//Move_modeならばmouseの動きについての処理を記述する
    container.addEventListener('mousemove', function(e) {
	if((Move_mode)&&(!isDrawing)) {
console.log('mouse move');
/*
		if (control.value== 'free_line'){
			isDrawing=true;
			mv_flag=0;
			drawingPoints=[];
console.log('Reset isDraw')
			
			}
		if ((control.value== 'quad_bezier') &&(Step==3)){
			isDrawing=true;
			mv_flag=1;
			}
		if ((control.value== 'cubic_bezier') &&(Step==4)){
			isDrawing=true;
			mv_flag=2;
			}
console.log('move_flag=',mv_flag,'Oper=',Oper);
		}
	switch(mv_flag){
		case 0:
            		drawingPoints.push({x: e.clientX,y: e.clientY});
            		if (drawingPath) {
                		container.removeChild(drawingPath);
console.log('remove point');
            			}
                	drawingPath = createPath(drawingPoints,0);
            		Object.assign(drawingPath.style, defaultPathStyle);
            		container.appendChild(drawingPath);
console.log('append point');
			break;
		case 1:
			if(drawingPoints.length==3) {
				drawingPoints.pop();
				}
            		drawingPoints.push({x: e.clientX,y: e.clientY});
            		if (drawingPath) {
                		container.removeChild(drawingPath);
console.log('remove bezier');
            			}
			if(Step==0){
				drawingPath=null;
				}
                	drawingPath = createQuadBezier(drawingPoints);
            		Object.assign(drawingPath.style, defaultPathStyle);
            		container.appendChild(drawingPath);
console.log('append bezier');
			break;
		case 2:
			if(drawingPoints.length==4) {
				drawingPoints.pop();
				}
            		drawingPoints.push({x: e.clientX,y: e.clientY});
            		if (drawingPath) {
                		container.removeChild(drawingPath);
console.log('remove cubic bezier');
            			}
			if(Step==0){
				drawingPath=null;
				}
                	drawingPath = createCubicBezier(drawingPoints);
            		Object.assign(drawingPath.style, defaultPathStyle);
            		container.appendChild(drawingPath);
console.log('append cubic bezier');
			break;
*/
		}
    });


    function createPath(points,close) {
        var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        var attribute = '';
        points.forEach((point, index) => {
            if (index === 0) {
                attribute += `M${point.x}, ${point.y}`;
            } else {
                attribute += `L${point.x}, ${point.y}`;
            }
        });
	if(close==true){
		attribute += ` Z`;
		}
        path.setAttributeNS(null, 'd', attribute);
console.log(path)
        return path;
    }

    function createQuadBezier(points) {
console.log('quad bezier','length=',points.length);
        var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        var attribute = '';
	var nx=2;
        points.forEach((point, index) => {
	    nx=nx+1;
	    mod3_nx=nx % 3;
console.log('nx=',nx,' mod3=',mod3_nx);
            if (mod3_nx== 0) {
		if(nx<4){
                	attribute += `M${point.x}, ${point.y}`;
            		} 
		else {
			attribute += `T${point.x}, ${point.y}`;
			}
		}
	    else if (mod3_nx==1) {
                attribute += `Q${point.x}, ${point.y}`;
            	}
	    else {
		attribute += ` ${point.x}, ${point.y}`;
		}
        });
        path.setAttributeNS(null, 'd', attribute);
console.log(path)
        return path;
    }

    function createCubicBezier(points) {
console.log('cubic bezier','length=',points.length);
        var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        var attribute = '';
	var nx=3;
        points.forEach((point, index) => {
	    nx=nx+1;
	    mod3_nx=nx % 4;
console.log('nx=',nx,' mod3=',mod3_nx);
            if (mod3_nx== 0) {
		if(nx<5){
                	attribute += `M${point.x}, ${point.y}`;
            		} 
		else {
			attribute += `T${point.x}, ${point.y}`;
			}
		}
	    else if (mod3_nx==1) {
                attribute += `C${point.x}, ${point.y}`;
            	}
	    else if (mod3_nx==2) {
                attribute += ` ${point.x}, ${point.y}`;
            	}
	    else {
		attribute += ` ${point.x}, ${point.y}`;
		}
        });
        path.setAttributeNS(null, 'd', attribute);
console.log(path)
        return path;
    }

//mouseup時の処理
    container.addEventListener('mouseup', function(e) {
	++Up_count;
console.log('mouse up');
	if(mouse_Error) {
		mouse_Error=false;
		Up_count=0;
		}
	if (Move_mode) {
console.log('canceled Move_mode');
/*
		Move_mode=0;
		Up_count=0;

		if ((control.value=='free_line')||(control.value=='quad_bezier')||(control.value=='cubic_bezier')){
			}
		else {
			return;
			}
        	isDrawing = false;
        	if (drawingPath) {
	        	container.removeChild(drawingPath);
			}
        	drawingPath = null;
       	 	var path;

        	if ((control.value === 'quad_bezier') && (Step==3)){
console.log('bezier mouseup');
            		path = createQuadBezier('',drawingPoints, 0);
	    		Step=1;
	    		var drawPoints=drawingPoints;
	   		 drawingPoints=[];
            		drawingPoints.push(drawPoints[2]);
            		if (bezier_line){
				container.removeChild(bezier_line);
				bezier_line=null;
console.log('bezier dummy removed length=',drawingPoints.length);
				}
			first_point=createFirstPoint(drawingPoints)
	        	Object.assign(first_point.style, defaultPointStyle);
        		container.appendChild(first_point)
		        }
        	else if ((control.value === 'cubic_bezier') && (Step==4)){
console.log('cubic bezier mouseup');
            		path = createCubicBezier(drawingPoints);
	    		Step=1;
	    		var drawPoints=drawingPoints;
	   		 drawingPoints=[];
            		drawingPoints.push(drawPoints[3]);
            		if (bezier_line){
				container.removeChild(bezier_line);
				bezier_line=null;
console.log('cubic bezier dummy removed length=',drawingPoints.length);
				}
			first_point=createFirstPoint(drawingPoints)
	        	Object.assign(first_point.style, defaultPointStyle);
        		container.appendChild(first_point)
		        }
		else {
console.log('line mouseup');
            		path = createPath(drawingPoints,0);
	    		drawingPoints = [];
        		}
        	Object.assign(path.style, defaultPathStyle);
        	container.appendChild(path);
		isDrawing=false;
		Oper=0;
		mv_flag=10;
*/
	}
    });

    function edit_mode(){
console.log("Enter Text EditMode");
	if(document.selbox.edit.selectedIndex==1){
		E_mode="Edit";
		}
	else {
		E_mode="Display";		
	}
	chng_mode();
    }

    function createFirstPoint(points) {
	circ1=document.createElementNS('http://www.w3.org/2000/svg','circle');
	circ1.setAttribute('cx',points[0].x);
	circ1.setAttribute('cy',points[0].y);
	circ1.setAttribute('r',4);
//	circ1.setAttribute('fill','red');
//	circ1.setAttribute('stroke','black');
//	svg.appendChild(circ1);
console.log(circ1)
        return circ1;
    }

    //メニューボタン管理
    function canvasMenu() {

     if(Editmode=='Svg'){
        //id 値によって場合分け
        var thisId = this.id;
        if (thisId.indexOf("size") + 1) {
            defaultPathStyle.strokeWidth = this.id.slice(4, this.id.length);
        }
        if (thisId.indexOf("color") + 1) {
            defaultPathStyle.stroke = "#" + this.id.slice(5, this.id.length);
        }
        if (thisId.indexOf("alpha") + 1) {
 //           defoalpha = (~~this.id.slice(5, this.id.length)) / 10;
        }
/*
        if (thisId.indexOf("clear") + 1) {
            //全消しボタン、OKされた場合は fillRect 長方形で覆います
            if (confirm("すべて消去しますか？")) {
                //ctx.fillStyle = "#f5f5f5";
                //ctx.globalAlpha = defoalpha;
   		//その描画状態を保存する
		ctx.clearRect(0, 0, 700, 400);
                //ctx.fillRect(0, 0, 700, 400);
console.log('fillStyle=',ctx.fillStyle);
		//sleep(2000);
		//svg_str='<svg width="700px" height="400px" >'
		//svg_str+=path_str+' /svg>';
//console.log('**canvg',svg_str);
		//canvg("myCanvas",svg_str);
                mouseX = "";
                mouseY = "";
            }
        }
*/
     }
     else {
	var selectedText = window.getSelection().toString();
	console.log(selectedText);
	var sel = window.getSelection();
	if(!sel.rangeCount) return; //範囲選択されている箇所がない場合は何もせず終了
	var range = sel.getRangeAt(0);　　　　　　　　　　　//　OK!!
        //id 値によって場合分け
        var thisId = this.id;
        if (thisId.indexOf("size") + 1) {
            var size = this.id.slice(4, this.id.length);
            if(size=='14px') {
		 h_size='h1'; 
		}
            if(size=='7px') {
		 h_size='h2'; 
		}
            if(size=='5px') {
		 h_size='h3'; 
		}
            if(size=='3px') {
		 h_size='h4'; 
		}
            if(size=='2px') {
		 h_size='h5'; 
		}
            if(size=='1px') {
		 h_size='h6'; 
		}
		const selectedText = window.getSelection().toString();
		console.log(h_size,selectedText);
		var sel = window.getSelection();
		if(!sel.rangeCount) return; //範囲選択されている箇所がない場合は何もせず終了
		  var range = sel.getRangeAt(0);　　　　　　　　　　　//　OK!!
		  var newNode = document.createElement(h_size);
		  newNode.innerHTML =  sel.toString();   //tag部分に<>を含むと変更出来ない。
		  range.deleteContents();    // 範囲選択箇所を一旦削除
		  range.insertNode(newNode); // 範囲選択箇所の先頭から、修飾したspanを挿入
        }

     }
    }

function chng_mode(){
console.log('**Enter change mode**',E_mode,'  ',Editmode)
    //選択したf_editによって分岐
    switch (document.selbox.fgedit.selectedIndex){
      case 0:               //     Visual mode
		Editmode="Tvis";
		nodisp=document.getElementById('tab2');
       		nodisp.style.display='none';
       		disp=document.getElementById('tab1');
       		disp.style.display='block';
//document.getElementById("bbb").style.display="block";
document.getElementById("myCanvas").style.display="block";
　　　　　　	document.getElementById("texh").contentEditable = false;
　　　　　　	document.getElementById("texx").contentEditable = false;
		document.getElementById( "texx" ).style.zIndex ='40';
		document.getElementById( "texh" ).style.zIndex ='20';
//		document.getElementById( "myCancas" ).style.zIndex ='20';
		document.getElementById("texx").innerHTML=document.getElementById("texh").value;
		if(E_mode=='Edit') {
			document.getElementById("texx").contentEditable = true;
			}
		break;
      case 1: 
		Editmode="Thtm";
		nodisp=document.getElementById('tab1');
        	nodisp.style.display='none';
        	disp=document.getElementById('tab2');
        	disp.style.display='block';
//document.getElementById("bbb").style.display="none";
document.getElementById("myCanvas").style.display="none";
　　　　　　	document.getElementById("texh").contentEditable = false;
　　　　　　	document.getElementById("texx").contentEditable = false;
		document.getElementById( "texh" ).style.zIndex ='40';
		document.getElementById( "texx" ).style.zIndex ='20';
//		document.getElementById( "myCancas" ).style.zIndex ='30';
		document.getElementById("texh").value=document.getElementById("texx").innerHTML;
		if(E_mode=='Edit') {
			document.getElementById("texh").contentEditable = true;
			}
		break;
      case 2: 
		Editmode="Svg";
		nodisp=document.getElementById('tab2');
       		nodisp.style.display='none';
       		disp=document.getElementById('tab1');
       		disp.style.display='block';
		document.getElementById("myCanvas").style.display="block";
　　　　　　	document.getElementById("texh").contentEditable = false;
　　　　　　	document.getElementById("texx").contentEditable = false;
		document.getElementById( "texh" ).style.zIndex ='10';
		document.getElementById( "texx" ).style.zIndex ='40';
		if(E_mode=='Edit') {
			document.getElementById( "texx" ).style.zIndex ='10';
			}
		
		break;
      case 3: 
		Editmode="ModSvg";
		nodisp=document.getElementById('tab2');
       		nodisp.style.display='none';
       		disp=document.getElementById('tab1');
       		disp.style.display='block';
		document.getElementById("myCanvas").style.display="block";
　　　　　　	document.getElementById("texh").contentEditable = false;
　　　　　　	document.getElementById("texx").contentEditable = false;
		document.getElementById( "texh" ).style.zIndex ='10';
		document.getElementById( "texx" ).style.zIndex ='40';
		if(E_mode=='Edit') {
			document.getElementById( "texx" ).style.zIndex ='10';
			}
		
		break;
    }
}
// ビジーwaitを使う方法
function sleep(waitMsec) {
  var startMsec = new Date();
 
  // 指定ミリ秒間だけループさせる（CPUは常にビジー状態）
  while (new Date() - startMsec < waitMsec);
}
function escapeHtml(convertString) {
    if (typeof convertString !== 'string') return convertString;
 
    var patterns = {
        '<'  : '&lt;',
        '>'  : '&gt;',
        '&'  : '&amp;',
        '"'  : '&quot;',
        '\'' : '&#x27;',
        '`'  : '&#x60;'
    };
 
    return convertString.replace(/[<>&"'`]/g, function(match) {
        return patterns[match];
    });
};
function unescapeHtml(target) {
    if (typeof target !== 'string') return target;
 
    var patterns = {
        '&lt;'   : '<',
        '&gt;'   : '>',
        '&amp;'  : '&',
        '&quot;' : '"',
        '&#x27;' : '\'',
        '&#x60;' : '`'
    };
 
    return target.replace(/&(lt|gt|amp|quot|#x27|#x60);/g, function(match) {
        return patterns[match];
    });
};


function catmullRom2bezier(pts){
    var cubics = [];
    for ( var i = 0, iLen = pts.length; i < iLen ; i++ ){
        var p = [
            pts[i - 1],
            pts[i],
            pts[i + 1],
            pts[i + 2]
        ];
        if( i === 0 ){
            p[0] = {
                x: pts[ 0 ].x,
                y: pts[ 0 ].y
            }
        }
        if( i === iLen - 2 ){
            p[3] = {
                x: pts[iLen - 2].x,
                y: pts[iLen - 2].y
            };
        }
        if ( i === iLen - 1 ) {
            p[2] = {
                x: pts[iLen - 1].x, 
                y: pts[iLen - 1].y
            };
            p[3] = {
                x: pts[iLen - 1].x, 
                y: pts[iLen - 1].y
            };
        }
      const val = 6;
        cubics.push([
            (-p[0].x + val * p[1].x + p[2].x) / val,
            (-p[0].y + val * p[1].y + p[2].y) / val,
            (p[1].x + val * p[2].x - p[3].x) / val,
            (p[1].y + val * p[2].y - p[3].y) / val,
            p[2].x,
            p[2].y
        ]);
    }
    return cubics;
}

function Cubic_interpol(pts){
   var iLen= pts.length;
   var cubics=[];
   var an=[];
   var slope=[];
   var vn=[];
   var wn=[];

   for ( var i = 0;  i < iLen ; i++ ){
	an[i]=0;
	slope[i]=0;
	vn[i]=[0,0];
	wn[i]=[0,0];
	}

   for ( var i = 1;  i < iLen-1 ; i++ ){
	var dx0=pts[i].x-pts[i-1].x;
	if(Math.abs(dx0)<0.1) {
		dx0=Math.sign(dx0)*0.1;
		}
	var dx1=pts[i+1].x-pts[i].x;
	if(Math.abs(dx1)<0.1) {
		dx1=Math.sign(dx1)*0.1;
		}
	dy0=pts[i].y-pts[i-1].y;
	dy1=pts[i+1].y-pts[i].y;
	an[i-1]=dy0/dx0;
	an[i]=dy1/dx1;
	var sx0=pts[i+1].x-pts[i-1].x;
	if(Math.abs(sx0)<0.1) {
		sx0=Math.sign(sx0)*0.1;
		}
	sy0=pts[i+1].y-pts[i-1].y;
	slope[i]=sy0/sx0;
	}

    var av=an[0];                         //直線an0(1,an0)に対する垂線のベクトル（1,dn0）を求める
    if(Math.abs(av)<0.1){
	var av=Math.sign(av)*0.1;
	}
    var x01=(pts[1].x+pts[0].x)/2;
    var y01=(pts[1].y+pts[0].y)/2;
    var dn0=-1/av;
    var dx0=slope[1]-dn0;
    if(Math.abs(dx0)<0.01){
	dx0=Math.sign(dx0)*0.01;
	}
    var dy0=slope[1]*pts[1].x-dn0*x01-pts[1].y+y01;
    var p01x=dy0/dx0;
    var p01y=slope[1]*(p01x-pts[1].x)+pts[1].y;
console.log('dn0= ',dn0,'center= ',x01,y01,'cross point= ',p01x,p01y);
    dx0=p01x-pts[0].x
    if(Math.abs(dx0)<0.1){
	var dx0=Math.sign(dx0)*0.1;
	}
    slope[0]=(p01y-pts[0].y)/dx0;

    var av=an[iLen-2];
    if(Math.abs(av)<0.1){
	var av=Math.sign(av)*0.1;
	}
    var x01=(pts[iLen-1].x+pts[iLen-2].x)/2;
    var y01=(pts[iLen-1].y+pts[iLen-2].y)/2;
    var dn0=-1/av;
    var dx0=slope[iLen-2]-dn0;
    if(Math.abs(dx0)<0.01){
	dx0=Math.sign(dx0)*0.01;
	}
    var dy0=slope[iLen-2]*pts[iLen-2].x-dn0*x01-pts[iLen-2].y+y01;
    var p01x=dy0/dx0;
    var p01y=slope[iLen-2]*(p01x-pts[iLen-2].x)+pts[iLen-2].y;
    dx0=p01x-pts[iLen-1].x
    if(Math.abs(dx0)<0.1){
	var dx0=Math.sign(dx0)*0.1;
	}
    slope[iLen-1]=(p01y-pts[iLen-1].y)/dx0;

    if((Math.abs(pts[0].x-pts[iLen-1].x)<1) && (Math.abs(pts[0].y-pts[iLen-1].y)<1)){
	var sx0=pts[1].x-pts[iLen-2].x;
	if(Math.abs(sx0)<0.1) {
		sx0=Math.sign(sx0)*0.1;
		}
	sy0=pts[1].y-pts[iLen-2].y;
	slope[0]=sy0/sx0;
	slope[iLen-1]=slope[0];
	}

console.log(' an slope =',an,slope);
var drawPoint=[];
var x0,y0,x1,x2;
   for ( var i = 0; i < iLen-1 ; i++ ){
drawPoint.push({x: pts[i].x,y: pts[i].y});
rr=Math.sqrt(1+slope[i]*slope[i]);
x0=pts[i].x+Math.sign(pts[i+1].x-pts[i].x)*100/rr;
y0=pts[i].y+Math.sign(pts[i+1].x-pts[i].x)*100*slope[i]/rr;
drawPoint.push({x: x0,y: y0});
console.log('Point0',x0,y0);
console.log(drawPoint);
bezier_line=createPath(drawPoint,0);
Object.assign(bezier_line.style, tempoPathStyle);
container.appendChild(bezier_line);
drawPoint=[];
//alert('JavaScriptのアラート');

	var vv=an[i]*slope[i]*pts[i].x+(2*pts[i].x+pts[i+1].x)/3-an[i]*(pts[i].y-pts[i+1].y)/3;
	var vm=an[i]*slope[i]+1;
	if(Math.abs(vm)<0.1){
		vm=Math.sign(vm)*0.1;
		}
	vn[i][0]=vv/vm;
	vn[i][1]=slope[i]*(vn[i][0]-pts[i].x)+pts[i].y;

drawPoint.push({x: pts[i+1].x,y: pts[i+1].y});
rr=Math.sqrt(1+slope[i+1]*slope[i+1]);
x1=pts[i+1].x-Math.sign(pts[i+1].x-pts[i].x)*100/rr;
y1=pts[i+1].y-Math.sign(pts[i+1].x-pts[i].x)*100*slope[i+1]/rr;
drawPoint.push({x: x1,y: y1});
console.log('Point0',x1,y1);
console.log(drawPoint);
bezier_line=createPath(drawPoint,0);
Object.assign(bezier_line.style, tempoPathStyle2);
container.appendChild(bezier_line);
drawPoint=[];

	var ww=an[i]*slope[i+1]*pts[i+1].x+(pts[i].x+2*pts[i+1].x)/3+an[i]*(pts[i].y-pts[i+1].y)/3;
	var wm=an[i]*slope[i+1]+1;
	if(Math.abs(wm)<0.1){
		wm=Math.sign(wm)*0.1;
		}
	wn[i][0]=ww/wm;
	wn[i][1]=slope[i+1]*(wn[i][0]-pts[i+1].x)+pts[i+1].y;
	}
console.log('vn ,wn=',vn,wn);

   for ( var i = 0; i < iLen-1 ; i++ ){
	cubics.push({x: pts[i].x,y: pts[i].y});
	cubics.push({x: vn[i][0],y: vn[i][1]});
	cubics.push({x: wn[i][0],y: wn[i][1]});
	}

   cubics.push({x: pts[iLen-1].x,y: pts[iLen-1].y});
console.log('Cubics=',cubics);
   return cubics;
}

function splitArray(array, part) {
    var tmp = [];
    for(var i = 0; i < array.length; i += part) {
        tmp.push(array.slice(i, i + part));
    }
    return tmp;
}

</script>

<!-- ポップアップウィンドウ用ベースHTML（テンプレート） -->
<script id="template-window" type="text/x-template">
<div class="popwindow-title"></div>
<button id="oper_01">oper_01</button>
<div class="popwindow-content"></div>
<div class="popwindow-buttons">
    <p class="popwindow-button-yes"><input type="button" value="Yes" /></p>
    <p class="popwindow-button-no"><input type="button" value="No" /></p>
</div>
</script>


<!-- ポップアップウィンドウの起動処理 -->
<script>
//ブラウザのload完了時にポップアップウィンドウを表示する
window.onload = function () {
    
    function createWindow() {
        
//        var title = document.getElementById('title').value;
//        var text = document.getElementById('content').value;
//        var isModal = document.getElementById('isModal').checked;
//        var isOnlyYes = document.getElementById('isOnlyYes').checked;
        var title = '';
        var text = "ドラッグで移動";
        var isModal = "false";
        var isOnlyYes = Popwindow.buttonType.YESNO;
        var conf = {
            title  : title,
            content: text,
            modal  : isModal,
            buttonType: isOnlyYes
        };
        
        var pop = new Popwindow(conf);
        pop.addListener('close', function () {
            console.log('ポップアップウィンドウが閉じられました。');
        });
    
        pop.addListener('yes', function () {
            console.log('Yesが押されました！');
        });
    
        pop.addListener('no', function () {
            console.log('Noが押されました！');
        });
        
        return pop;
    }
    
    var btn = document.getElementById('createWindow');
    
    //クリックすると新しいポップアップウィンドウを生成
    btn.addEventListener('click', function () {
        createWindow();
    }, false);

    var popTutorial = createWindow();  
    
    //最初のチュートリアルが閉じたタイミングでYESボタンのみフラグをオフに。
    popTutorial.addListener('close', function () {
        var isOnlyYes = document.getElementById('isOnlyYes');
        isOnlyYes.checked = false;
    });

    $(document).on('click', '#oper_01', function(){
	console.log('Oper_01が押されました');
	});
};
</script>
<!-- script src="main.js"></script -->
{% include 'db_serv/footer.html' %}
